<html>

  <head>
    <title>WebGL Beginner's Guide - Chapter 3 - Phong Shading + Phong Lighting</title>
    <meta http-equiv='content-type' content='text/html; charset=ISO-8859-1'>

    <!-- CSS Styles //-->
    <link href='css/style.css'   type='text/css' rel='stylesheet'>
    <link href='css/desert.css'  type='text/css' rel='stylesheet'/>
    <link href='css/colorpicker.css'  type='text/css' rel='stylesheet'/>
    <link href='css/smoothness/jquery-ui-1.8.13.custom.css' type='text/css' rel='stylesheet' />

    <!-- JavaScript Libraries //-->
    <script type='text/javascript' src='js/gl-matrix-min.js'></script>
    <script type='text/javascript' src='js/jquery-1.5.1.min.js'></script>
    <script type='text/javascript' src='js/jquery-ui-1.8.13.custom.min.js'></script>
    <script type='text/javascript' src='js/prettify.js'></script>
    <script type='text/javascript' src='js/utils.js'></script>
    <script type='text/javascript' src='js/colorpicker.js'></script>
    <script type='text/javascript' src='js/codeview.js'></script>


    <!-- vertex shader -->
    <script id="shader-vs" type="x-shader/x-vertex">

     attribute vec3 aVertexPosition;
     attribute vec3 aVertexNormal;

     uniform mat4 uNMatrix;
     uniform mat4 uMVMatrix;
     uniform mat4 uPMatrix;

     uniform vec3 uLightDirection;
     uniform vec4 uLightDiffuse;
     uniform vec4 uLightAmbient;
     uniform vec4 uMaterialDiffuse;

     varying vec4 vFinalColor;

     void main(void){

         /* transformed lightdirection vertexnormal and vertex position */
         vec3 N = vec3(uNMatrix * vec4(aVertexNormal, 1.0));
         vec3 L = normalize(uLightDirection);

         /* Lambert term */
         float lambertTerm = dot(N, -L);

         /* Ambient Term */
         vec4 Ia = uLightAmbient;

         /* Diffuse Term */
         vec4 Id = uLightDiffuse * uMaterialDiffuse * lambertTerm;

         /* Final color */
         vFinalColor = Ia + Id;
         vFinalColor.a = 1.0;

         /* Final vertex position */
         /* yiddi:here 'gl_Position' is a variable defined in the imported js lib. */
         gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);

     }

    </script>

    <!-- fragment shader -->
    <script id="shader-fs" type="x-shader/x-fragment">
     #ifdef GL_ES
     precision highp float;
     #endif

     varying vec4 vFinalColor;

     void main(void){
         /* yiddi:here 'gl_FragColor' is a variable defined in the imported js lib. */
         gl_FragColor = vFinalColor;

     }

    </script>

    <script id="code-js" type="text/javascript">

     /* model loaded from json file */
     var model = null;
     var modelLoaded = false;

     /* canvas
        yiddi: here you should not using variable name except these two,
        because the global variables definition in utils.js lib.*/
     var c_width = 0;
     var c_height = 0;

     /* webgl */
     var gl = null;
     var prg = null;

     /* transformed matrix */
     var uMVMatrix = mat4.create();
     var uPMatrix = mat4.create();
     var uNMatrix = mat4.create();

     var vbo;
     var ibo;
     var nbo;


     /* yiddi: if you load model from the json file, these variables don't need
      * to define, just using parser API extract model from json, and access *
        the vertex/index array by 'model.vertices' */
     var varr;
     var iarr;
     var narr;


     function loadModel(filename){
         var request = new XMLHttpRequest();
         var resource = "http://"+document.domain+ filename
         request.open("GET",filename);
         request.onreadystatechange = function() {
             console.info(request.readyState +' - '+request.status);
             if (request.readyState == 4) {
                 if(request.status == 200) { //OK
                     handleLoadedModel(filename,JSON.parse(request.responseText));
                 }
                 else if (document.domain.length == 0 && request.status == 0){ //OK but local, no web server
                     handleLoadedModel(filename,JSON.parse(request.responseText));
                 }
                 else{
                     alert ('There was a problem loading the file :' + filename);
                     alert ('HTML error code: ' + request.status);
                 }
             }
         }
         request.send();
     }


     function handleLoadedModel(filename, payload){

         model = payload; //save our model in a global variable so we can retrieve it in drawScene

         narr = utils.calculateNormals(model.vertices, model.indices);

         alert(filename + ' has been retrieved from the server');

         /* create a buffer and bind with vbo */
         vbo = gl.createBuffer();
         gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
         gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(model.vertices), gl.STATIC_DRAW);
         /* alert(model.vertices) */

         /* create a buffer and bind with nbo */
         nbo = gl.createBuffer();
         gl.bindBuffer(gl.ARRAY_BUFFER, nbo);
         gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(narr), gl.STATIC_DRAW);
         /* alert(narr) */

         /* create a buffer and bind with ibo */
         ibo = gl.createBuffer();
         gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
         gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(model.indices), gl.STATIC_DRAW);
         /* alert(model.indices) */

         gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
         gl.bindBuffer(gl.ARRAY_BUFFER,null);

         /* gl.uniform3f(prg.modelColor,model.color[0], model.color[1],model.color[2]); */

         modelLoaded = true;

     }

     function initProgram(){

         /* get shader code from js tag file */
         var vxShader = utils.getShader(gl, "shader-vs");
         var fgShader = utils.getShader(gl, "shader-fs");

         /* create a program */
         prg = gl.createProgram();

         /* attach shader with program */
         gl.attachShader(prg, vxShader);
         gl.attachShader(prg, fgShader);



         /* link program to make a executable version */
         gl.linkProgram(prg);

         if(!gl.getProgramParameter(prg, gl.LINK_STATUS)) {
             alert('could not initialize shaders');
         }

         /* initialize the program and bind js variables */
         gl.useProgram(prg);

         prg.aVertexPosition                 = gl.getAttribLocation(prg, 'aVertexPosition');
         prg.aVertexNormal                   = gl.getAttribLocation(prg, 'aVertexNormal');

         prg.uPMatrix                        = gl.getUniformLocation(prg, 'uPMatrix');
         prg.uMVMatrix                       = gl.getUniformLocation(prg, 'uMVMatrix');
         prg.uNMatrix                        = gl.getUniformLocation(prg, 'uNMatrix');

         prg.uLightDirection                 = gl.getUniformLocation(prg, 'uLightDirection');
         prg.uLightAmbient                   = gl.getUniformLocation(prg, "uLightAmbient");
         prg.uLightDiffuse                   = gl.getUniformLocation(prg, 'uLightDiffuse');
         prg.uMaterialDiffuse                = gl.getUniformLocation(prg, 'uMaterialDiffuse');

         /* console log for debug */
         console.log( prg.aVertexPosition                       );
         console.log( prg.aVertexNormal                         );

         console.log( prg.uPMatrix                              );
         console.log( prg.uMVMatrix                             );
         console.log( prg.uNMatrix                              );

         console.log( prg.uLightDirection                       );
         console.log( prg.uLightAmbient                         );
         console.log( prg.uLightDiffuse                         );
         console.log( prg.uMaterialDiffuse                      );

     }

     function initLights(){
         gl.uniform3fv(prg.uLightDirection,    [0.0, 0.0, -1.0]);
         gl.uniform4fv(prg.uLightAmbient,      [0.01, 0.01, 0.01, 1.0]);
         gl.uniform4fv(prg.uLightDiffuse,      [0.5,  0.5,  0.5,  1.0]);
         gl.uniform4fv(prg.uMaterialDiffuse,   [0.1, 0.5, 0.8, 1.0]);

         /* output uniform to console for debug */
         console.log(gl.getUniform(prg, prg.uLightDirection));
         console.log(gl.getUniform(prg, prg.uLightAmbient));
         console.log(gl.getUniform(prg, prg.uLightDiffuse));
         console.log(gl.getUniform(prg, prg.uMaterialDiffuse));

     }

     /* implement everytime hiting a key, the light orientation changes */
     var azimuth = 0;
     var elevation = 0;

     document.onkeydown = processKey;

     function processKey(ev) {

         console.log("entger processKey()");

         var lightDirection = gl.getUniform(prg, prg.uLightDirection);
         var incrAzimuth = 10;
         var incrElevation = 10;

         switch(ev.keyCode) {
             case 37:{ // left arrow
                 azimuth -= incrAzimuth;
                 break;
             }
             case 38:{ // up arrow
                 elevation += incrElevation;
                 break;
             }
             case 39:{ // right arrow
                 azimuth += incrAzimuth;
                 break;
             }
             case 40:{ // down arrow
                 elevation -= incrElevation;
                 break;
             }
         }

         azimuth %= 360;
         elevation %= 360;

         var theta = elevation * Math.PI / 180;
         var phi = azimuth * Math.PI / 180;

         // Spherical to Cartesian coordinate transformation
         lightDirection[0] = Math.cos(theta) * Math.sin(phi);
         lightDirection[1] = Math.sin(theta);
         lightDirection[2] = Math.cos(theta) * -Math.cos(phi);

         gl.uniform3fv(prg.uLightDirection, lightDirection);
     }


     function drawScene(){

         /* parameters of clearColor() give the new background color of this scene */
         gl.clearColor(0.12,0.12,0.12, 1.0);

         gl.clearDepth(100.0);

         gl.enable(gl.DEPTH_TEST);

         gl.depthFunc(gl.LEQUAL);
         gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
         gl.viewport(0, 0, c_width, c_height);

         mat4.perspective(45, c_width / c_height, 0.1, 10000.0, uPMatrix);
         mat4.identity(uMVMatrix);
         mat4.translate(uMVMatrix, [0.0, 0.0, -40.0]);

         gl.uniformMatrix4fv(prg.uPMatrix, false, uPMatrix);
         gl.uniformMatrix4fv(prg.uMVMatrix, false, uMVMatrix);


         mat4.set(uMVMatrix, uNMatrix);
         mat4.inverse(uNMatrix);
         mat4.transpose(uNMatrix);

         gl.uniformMatrix4fv(prg.uNMatrix, false, uNMatrix);

         try{

             /* Enabling Vertex Attributes */
             gl.enableVertexAttribArray(prg.aVertexPosition);
             gl.enableVertexAttribArray(prg.aVertexNormal);


             if(!modelLoaded) return;

             /* Bind webgl buffer with related prg attribute */
             gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
             gl.vertexAttribPointer(prg.aVertexPosition, 3, gl.FLOAT, false, 0, 0);
             gl.bindBuffer(gl.ARRAY_BUFFER, nbo);
             gl.vertexAttribPointer(prg.aVertexNormal, 3, gl.FLOAT, false, 0,0);

             /* Bind indices buffer and draw */
             gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
             gl.drawElements(gl.TRIANGLES, model.indices.length, gl.UNSIGNED_SHORT, 0);

             /* release the binding */
             gl.bindBuffer(gl.ARRAY_BUFFER, null);
             gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
         }
         catch(err){
             alert(err);
             message(err.description);
         }

     }


     /* all codes in this function will be called repeat every time inteval. */
     function renderLoop(){
         requestAnimFrame(renderLoop);
         drawScene();

     }

     function runWebGLAPP(){

         /* obtains a webgl context */
         gl = utils.getGLContext('canvas-element-id');

         /* create program, bind with js code, and make it executable. */
         initProgram();

         /* load model, include vertex and indices from server */
         loadModel('models/YIDDI_walls/wall.json');

         /* using js code initialize the light and direction etc. */
         initLights();

         /* rendering */
         renderLoop();

     }

    </script>

  </head>


  <body onLoad='runWebGLAPP()'>

    <div id="top"> </div>

    <div id="contents">
      <div id="canvasContainer">
        <canvas id="canvas-element-id" width="480" height="400">
          Your browser does not support
        </canvas>
      </div>
      <div id="controls"> </div>

      <div id="bottom"> </div>

      <script>cview.run(cview.MODE_VIEW, true);</script>

  </body>

</html>
